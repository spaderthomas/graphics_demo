* old notes
** state
-- 12/10
kind of like triggers in a database, or a wave propagation algorithm. which
sounds hard to write -- it's like you have some arbitrary piece of state
change. that goes through a state manager which holds a bunch of callbacks for
when that state changes. problem with this is that each piece of state has to be
uniquely identified in some way, and i saw that when i wrote it naively with
that FSM stuff that that quickly becomes cumbersome. you have really long names
for all the pieces of state or scenes that you can be in, and it's hard to
remember which one you need when you're scripting. now, maybe a good gui could
solve that problem. 

dichotomy between where state needs to be know. for example, if there's some
small insular quest that you need to do, probably only the entity involved in
the quest needs to know about that piece of state. but what if you make a big
story decision that affects things which are going to propagate to pretty much
everything? is it alright to store that globally? having global structs and
things that you interact with is, in all honesty, not that bad of a model. on
the one hand it puts all the places you e.g. interact with state in one
place. but on the other hand, it lets you actually change shit from about a
thousand different places. have i actually had a problem with that?

example: the interaction system. here's what happens with interactions:
1. the main game loop checks if you've pressed the interaction button and if you
   are close enough to interact with the thing.
2. tdapi are_interacting() gets called. if the appropriate boxes intersect, then
   you set the interaction component's was_interacted_with flag. this is so that
   you can defer decisions about what to do on interaction to a later point in
   time.
3. when a task needs to tell if something was interacted with, it checks this
   flag and resets it

but there are some problems here. first off, are_interacting isn't a big system
that everything goes through -- it's not really clear that this is the thing
that's modifying all these interaction components. it's just a random API
function. this, i think, is the appeal behind functional programming. you need
to have side effects somewhere in your program, yeah, but spreading them out
in a million places makes your shit hard to debug. so, middle of the road
approach here -- i don't want to follow some strict paradigm where i can only
change things in highly specific circumstances. just make sure, generally, that
when you are merely /checking/ something that you aren't also doing a thing
based on that result. make sure that the thing that gets done is (generally) in
a centralized place. 

so, what do i do about components which need to hold ephemeral state? 

also, as an aside, about the interactions. the current way of doing it might
actually be correct -- when you interact with something, you store that it was
interacted with and you hold onto that value until there is a task with that
entity that needs to know about interactions.

also, tasks vs components. because it's kind of weird that behavior can be
stored in either. so i think that components serve two purposes:
1. storing data
2. defining behavior

tasks serve one purpose:
1. synthesize the data and behavior definitions into high-level goals

systems serve one purpose:
1. use data to do low-level computations (rendering, collision detection)

but there should never be a function of a component that actually updates stuff!
it's like a plugin for some piece of data or behavior. a graphic component tells
you what animations you have and what you should draw this frame, but it does
not actually do the drawing!

systems in the game: 
1. input system: low-level determining of what buttons were pressed, absolutely
   no game logic
2. physics system: also low-level -- at it's core, this is just getting a bunch
   of boxes and making them not touch
3. task system: 
4. rendering system: grab pictures and render them in the right place

ok god damn it, it actually seems pretty good. task stuff is in its infancy but
i like where it's going. 

again, a clear definition of the problem at hand. the only thing entities ever
do is tasks. i need to figure out what tasks need to be active. this is a
function of actions the player has taken throughout the course of the game, and
nothing else. then the problem is really to create a mapping between game state
and entity tasks which:
1. is easy to edit
2. scales

idea 1: triggers
- keep every decision the player can make (i.e. state) in a database.
- register callbacks for each piece of state. when that state changes, the game
  will run all of the callbacks associated with it.
- a callback will:
  - have an associated entity
  - check if the entity's current states' transitions have been satisfied
  - update the database to mark the new state
  - set the entity's task to the new one

now, problems with this. first of all, how can you guarantee that the handle
passed in is still the one you care about? imagine changing levels, unloading a
bunch of entities, and then loading some new ones. now, the handle that you
passed in is not the same handle you're updating. the solution to this is to
modify things in the /database/, that way when entities get reloaded, they have
the new state they should be in. but -- what happens if the handle passed in IS
valid, and you do want to update its state -right now-? 

now, don't forget the assumption that in this game there will only every be one
of any kind of entity in existence at one time. there aren't, say, guards that
you want to have 4-5 of. that simplifies things. you can just loop over all the
entities in your game, and if their state should change, you change it.

--- 12/11, 9:00 PM

right, so here's what i'm going to do. every character's state is going to be
kept in a database. the key being the character's lua id and the value being the
index into that character's state machine table. 

when a piece of state gets updated, i'm going to go through every character and
check if the transitions for their current state are satisfied. 

cool. so now that's done. now what i have to do is make sure that when entities
are loaded, they get the appropriate task loaded in from
npc.name.State_Machine.my_state. also, i need to make sure that this works with
entities other than NPCs. honestly, this will probably just entail changing the
npc.lua script to entities.lua and then modifying the table names accordingly

-- 12/12, 5:31 PM

the above still holds. however, i also need to think of the best way to store
tasks in the game. i already have all the task definitions in lua. the complete
mapping of state to task is there -- it's just, when you need to update
something's task, what structure is that in? probably a component, right?
anything that is done 

maybe formalizing it will help me make sure that it sounds good.

to add scripting to an entity:
1. give the entity an empty Task_Component
2. make sure there is an entry for the entity in the entity_state table
3. add scripts to npc.entity_name.scripts
   - names of scripts much match names of states
   - ditto transitions

-- 12/20 2:46 PM

ok! so i can actually script stuff now. i can add all kinds of different actions
and they get dispatched and updated. now, editing them. 

-- 12/22 12:17 AM

so nested assignments. first, the easy case. when you have something in the
global scope such as
existing_table.new_field = 1

when you parse the identifier, you want to check if it is a nested
assignment. if it is, go get the innermost table referred to and add a field to
it. by that, i mean 

-- 3/12
1. tds.dump(obj)
2. 
#+BEGIN_SRC 
character_state = {
    intro_police = default,
    wilson = default,
    # ...
}

game_state = {
    intro_door_answered = false,
    # ...
}
#+END_SRC
3. 
#+BEGIN_SRC cpp
tds_set()
#+END_SRC
4. 
#+BEGIN_SRC cpp
map<string, vector<string>> need_update;

void update_state(string name, bool value) {
	tds_set(...); // actually set the state (i.e. game_state table)

	vector<string>& entities_to_check = need_update[name];
    for (auto& kvp : entities_to_check) {
		string entity_state = tds_str(...);

		TableNode* transitions = tds_table(...);
		for (auto& transition : transitions) {
			// check if entity can update state
			// if so, do it

			if (did_update) {
				for (auto& entity : entities) {
					// make their state component update
					// make them load in their new tasku
				}
			}
		}
	}

}
#+END_SRC
5. 
#+BEGIN_SRC cpp
State_Component::next_state() {
	// grab the table for current state
	// check which transition is satisfied
	// go there
}
#+END_SRC
note: use smart names + abc order so it's easy to find stuff

-- 3/14 2:24 pm

I need a good way to update an instantiated entity's state when a variable gets
changed. The dumbest way to do this would be this: 

When you figure that an entity has to go to a new state, you go to the big list
of instantiated entities (right now, stored in the Level). You loop through it
until you find the one that matches. You tell it to move to a new state and load
a new task. 
* The Big List
- Finish the story
  - Flesh out all of the characters
  - Write sidequests
  - Fine-tune pacing
- Balance the in-game
  - What creatures are in the game?
  - What moves are in the game?
  - What items are in the game?
  - What abilities are in the game?
  - How and at what rate do creatures become more powerful?
  - When do you have access to certain creatures?
- Balance the out of game
  - What does the metagame look like?
  - What macro strategies are available? 
- Design dungeons
  - Puzzles
  - Difficulty
- Art
  - Characters
	- Sprites
	- Heads
  - Battle Stuff
	- Creatures
	- Attacks
	- Items
  - Flashes
	- Pastoral Society
	- Smoldering Ruins
	- Mountain Pass
	- Frightened Deer
  - Levels
	- Boon's House
	- The City
	  - Boon's Neighborhood
	  - The Poor Area
	  - Ike's Hardware
	  - The Basement
	  - The Bar
	  - Announcement Podium
	  - The Restaurant
	- The Forest
	  - Camp
	  - Cream Palace
	- The Desert
	  - Barr's Outpost
	  - Landscape
	- Theseus' Lair
  - Dungeons
	- The Warehouse
	- The Slave Factory
	- The Police Station
	- The Capturehouse
	- The Forest (Boon)
	- The Forest (Sewell + Evans)
	- The Tunnel
	- The Mirage + The House
	- The Encampment
	- The Shed
- Music
* bugs
@spader 9/7/2019: The install script doesn't work on windows because the
backslash escapes the closing quotation mark. 

@spader 9/20/2019: You can't select a cactus

@spader 9/20/2019: You can't remove tiles unless you're using undo

@spader 9/22/2019: TDS should do some kind of conversions for integers and
floats. 
@spader 9/26/2019: When you add an entity, you have to run the prebuild script
to get it to show up in the chooser. It's probably better to generate that file
as TDS or something else that C++ can read and parse into a native structure,
rather than a native C++ map. 
* qol
@spader 9/22/2019: Use tdengine as a command line program. First thing: Add an
action from the command line. Action headers go in a folder, and the CLI
generates a new header into that folder. win_main can just #include
"actions/action_includes.hpp". Would save me from writing a lot of boilerplate. 

@spader 9/20/2019: Move all the flags in utils.hpp into a TDS file. 
@spader 9/22/2019: Also, have the engine watch this file for updated timestamp
and automatically reload it. 

@spader 9/22/2019: Format arguments for log writing. 

@spader 9/22/2019: Move globals into a big struct, mostly for ease of
readability. 

@spader 9/10/2019: Do something better than a fat union and a mapping of
string::type_id for handling components. Maybe use base pointers like a real
boy. 

@spader 9/8/2019: Rename State_Machine key to state.

@spader 9/8/2019: Make it so that you can automatically create a sub-table
without forward declaring it

@spader 9/10/2019: Make an emacs extension for tds

@spader 9/10/2019: Move more stuff over from This_Case to ThisCase

@spader 9/20/2019: A more automated way to make entities. 
A Python script?
An interactive Python script?
Something built into the engine?
* polish
@spader 9/8/2019: Fade-out/Fade-in for doors
* switching layers
objective one: i want changes in the editor to effect the other layers. if i add
some entity in the editor, i want it to be there when i tab over to the
game. i want it to be there when i tab over to the cutscene tester. but this
isn't always the case. when i change shit in the game, i don't want it to touch
the editor. the cutscene tester should be isolated too. after writing this out,
it seems a lot clearer what i should do. 

the editor needs to hold its own state. maybe this means make the levels and
stuff non-global, but i'm not sure. when you swap out from the editor, it's
gonna take all the shit it has and put it somewhere. when you swap back to it,
it's going to restore all that shit. 

you also want to be able to tab over to the game, do whatever, tab to the
editor, do whatever, and then be back in the same state in the game as before.

i dunno now. because there's some shit you want to be in a different state, and
some shit you want to keep the same. if entities start moving around and shit,
you want the game to just 'freeze'. no changes. but if you add tiles, you want
that change to be reflected in the game. is there some kind of pattern between
changes i do want to see and changes i don't want to see? 

-- 9/11/2019 00:22

one clear change that i can make is to get rid of the cutscene layer. when you
want to test a cutscene, just run the console command from the game. the game
will save its old state, load up everything for the cutscene, and then restore
it. 

that might just fix everything. 

in the editor, don't update tasks. everything is frozen. or make it a checkbox,
in case you do want that. 

another idea. levels are split into two. one is a backdrop, the other is
actors. anything that's just there becomes a part of the backdrop. you can
always reuse the same backdrop. but then you have to keep the actors aligned, so
that's the same problem as i had before. i think it's best to save/restore. 

-- 9/22/2019 5:10

just need to jot down some thoughts about how i handle cutscenes and stuff...

i want to be able to fuck with cutscenes two ways: 
1. i'm playing the game, i can flip some bits through the editor or through the
   game itself, and then i can see if the cutscene triggers and if it does what
   i want it to do. "integration test".
2. i want to see if the cutscene just works mechanically. "unit test". 

right now the cutscene action loads up the cutscene test layer and triggers a
cutscene from that. that's definitely not what i want to do. first off, adding a
new layer was kind of a pain in the ass because it was easy to forget stuff
(update the console! do physics! update the camera!). second off, the -only-
thing that layer does is to run a cutscene. so it's just a kind of bullshit
piece of code. 

i could probably just smush that into the editor? 

also, side note, the battle layer is pretty whatever, so don't worry about
that. 

another thing with cutscenes, and i don't know if i am making shit too
complicated here, but doesn't there need to be a set state for a cutscene to
work? as in, should a cutscene only trigger if some certain flags are properly
set? i don't think so...this game is supposed to be linear. so if that is the
case, then i can just trigger a cutscene from literally anywhere and it will
work. 
