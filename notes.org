* old notes
** state
-- 12/10
kind of like triggers in a database, or a wave propagation algorithm. which
sounds hard to write -- it's like you have some arbitrary piece of state
change. that goes through a state manager which holds a bunch of callbacks for
when that state changes. problem with this is that each piece of state has to be
uniquely identified in some way, and i saw that when i wrote it naively with
that FSM stuff that that quickly becomes cumbersome. you have really long names
for all the pieces of state or scenes that you can be in, and it's hard to
remember which one you need when you're scripting. now, maybe a good gui could
solve that problem. 

dichotomy between where state needs to be know. for example, if there's some
small insular quest that you need to do, probably only the entity involved in
the quest needs to know about that piece of state. but what if you make a big
story decision that affects things which are going to propagate to pretty much
everything? is it alright to store that globally? having global structs and
things that you interact with is, in all honesty, not that bad of a model. on
the one hand it puts all the places you e.g. interact with state in one
place. but on the other hand, it lets you actually change shit from about a
thousand different places. have i actually had a problem with that?

example: the interaction system. here's what happens with interactions:
1. the main game loop checks if you've pressed the interaction button and if you
   are close enough to interact with the thing.
2. tdapi are_interacting() gets called. if the appropriate boxes intersect, then
   you set the interaction component's was_interacted_with flag. this is so that
   you can defer decisions about what to do on interaction to a later point in
   time.
3. when a task needs to tell if something was interacted with, it checks this
   flag and resets it

but there are some problems here. first off, are_interacting isn't a big system
that everything goes through -- it's not really clear that this is the thing
that's modifying all these interaction components. it's just a random API
function. this, i think, is the appeal behind functional programming. you need
to have side effects somewhere in your program, yeah, but spreading them out
in a million places makes your shit hard to debug. so, middle of the road
approach here -- i don't want to follow some strict paradigm where i can only
change things in highly specific circumstances. just make sure, generally, that
when you are merely /checking/ something that you aren't also doing a thing
based on that result. make sure that the thing that gets done is (generally) in
a centralized place. 

so, what do i do about components which need to hold ephemeral state? 

also, as an aside, about the interactions. the current way of doing it might
actually be correct -- when you interact with something, you store that it was
interacted with and you hold onto that value until there is a task with that
entity that needs to know about interactions.

also, tasks vs components. because it's kind of weird that behavior can be
stored in either. so i think that components serve two purposes:
1. storing data
2. defining behavior

tasks serve one purpose:
1. synthesize the data and behavior definitions into high-level goals

systems serve one purpose:
1. use data to do low-level computations (rendering, collision detection)

but there should never be a function of a component that actually updates stuff!
it's like a plugin for some piece of data or behavior. a graphic component tells
you what animations you have and what you should draw this frame, but it does
not actually do the drawing!

systems in the game: 
1. input system: low-level determining of what buttons were pressed, absolutely
   no game logic
2. physics system: also low-level -- at it's core, this is just getting a bunch
   of boxes and making them not touch
3. task system: 
4. rendering system: grab pictures and render them in the right place

ok god damn it, it actually seems pretty good. task stuff is in its infancy but
i like where it's going. 

again, a clear definition of the problem at hand. the only thing entities ever
do is tasks. i need to figure out what tasks need to be active. this is a
function of actions the player has taken throughout the course of the game, and
nothing else. then the problem is really to create a mapping between game state
and entity tasks which:
1. is easy to edit
2. scales

idea 1: triggers
- keep every decision the player can make (i.e. state) in a database.
- register callbacks for each piece of state. when that state changes, the game
  will run all of the callbacks associated with it.
- a callback will:
  - have an associated entity
  - check if the entity's current states' transitions have been satisfied
  - update the database to mark the new state
  - set the entity's task to the new one

now, problems with this. first of all, how can you guarantee that the handle
passed in is still the one you care about? imagine changing levels, unloading a
bunch of entities, and then loading some new ones. now, the handle that you
passed in is not the same handle you're updating. the solution to this is to
modify things in the /database/, that way when entities get reloaded, they have
the new state they should be in. but -- what happens if the handle passed in IS
valid, and you do want to update its state -right now-? 

now, don't forget the assumption that in this game there will only every be one
of any kind of entity in existence at one time. there aren't, say, guards that
you want to have 4-5 of. that simplifies things. you can just loop over all the
entities in your game, and if their state should change, you change it.

--- 12/11, 9:00 PM

right, so here's what i'm going to do. every character's state is going to be
kept in a database. the key being the character's lua id and the value being the
index into that character's state machine table. 

when a piece of state gets updated, i'm going to go through every character and
check if the transitions for their current state are satisfied. 

cool. so now that's done. now what i have to do is make sure that when entities
are loaded, they get the appropriate task loaded in from
npc.name.State_Machine.my_state. also, i need to make sure that this works with
entities other than NPCs. honestly, this will probably just entail changing the
npc.lua script to entities.lua and then modifying the table names accordingly

-- 12/12, 5:31 PM

the above still holds. however, i also need to think of the best way to store
tasks in the game. i already have all the task definitions in lua. the complete
mapping of state to task is there -- it's just, when you need to update
something's task, what structure is that in? probably a component, right?
anything that is done 

maybe formalizing it will help me make sure that it sounds good.

to add scripting to an entity:
1. give the entity an empty Task_Component
2. make sure there is an entry for the entity in the entity_state table
3. add scripts to npc.entity_name.scripts
   - names of scripts much match names of states
   - ditto transitions

-- 12/20 2:46 PM

ok! so i can actually script stuff now. i can add all kinds of different actions
and they get dispatched and updated. now, editing them. 

-- 12/22 12:17 AM

so nested assignments. first, the easy case. when you have something in the
global scope such as
existing_table.new_field = 1

when you parse the identifier, you want to check if it is a nested
assignment. if it is, go get the innermost table referred to and add a field to
it. by that, i mean 

-- 3/12
1. tds.dump(obj)
2. 
#+BEGIN_SRC 
character_state = {
    intro_police = default,
    wilson = default,
    # ...
}

game_state = {
    intro_door_answered = false,
    # ...
}
#+END_SRC
3. 
#+BEGIN_SRC cpp
tds_set()
#+END_SRC
4. 
#+BEGIN_SRC cpp
map<string, vector<string>> need_update;

void update_state(string name, bool value) {
	tds_set(...); // actually set the state (i.e. game_state table)

	vector<string>& entities_to_check = need_update[name];
    for (auto& kvp : entities_to_check) {
		string entity_state = tds_str(...);

		TableNode* transitions = tds_table(...);
		for (auto& transition : transitions) {
			// check if entity can update state
			// if so, do it

			if (did_update) {
				for (auto& entity : entities) {
					// make their state component update
					// make them load in their new tasku
				}
			}
		}
	}

}
#+END_SRC
5. 
#+BEGIN_SRC cpp
State_Component::next_state() {
	// grab the table for current state
	// check which transition is satisfied
	// go there
}
#+END_SRC
note: use smart names + abc order so it's easy to find stuff

-- 3/14 2:24 pm

I need a good way to update an instantiated entity's state when a variable gets
changed. The dumbest way to do this would be this: 

When you figure that an entity has to go to a new state, you go to the big list
of instantiated entities (right now, stored in the Level). You loop through it
until you find the one that matches. You tell it to move to a new state and load
a new task. 
** switching layers
objective one: i want changes in the editor to effect the other layers. if i add
some entity in the editor, i want it to be there when i tab over to the
game. i want it to be there when i tab over to the cutscene tester. but this
isn't always the case. when i change shit in the game, i don't want it to touch
the editor. the cutscene tester should be isolated too. after writing this out,
it seems a lot clearer what i should do. 

the editor needs to hold its own state. maybe this means make the levels and
stuff non-global, but i'm not sure. when you swap out from the editor, it's
gonna take all the shit it has and put it somewhere. when you swap back to it,
it's going to restore all that shit. 

you also want to be able to tab over to the game, do whatever, tab to the
editor, do whatever, and then be back in the same state in the game as before.

i dunno now. because there's some shit you want to be in a different state, and
some shit you want to keep the same. if entities start moving around and shit,
you want the game to just 'freeze'. no changes. but if you add tiles, you want
that change to be reflected in the game. is there some kind of pattern between
changes i do want to see and changes i don't want to see? 

-- 9/11/2019 00:22

one clear change that i can make is to get rid of the cutscene layer. when you
want to test a cutscene, just run the console command from the game. the game
will save its old state, load up everything for the cutscene, and then restore
it. 

that might just fix everything. 

in the editor, don't update tasks. everything is frozen. or make it a checkbox,
in case you do want that. 

another idea. levels are split into two. one is a backdrop, the other is
actors. anything that's just there becomes a part of the backdrop. you can
always reuse the same backdrop. but then you have to keep the actors aligned, so
that's the same problem as i had before. i think it's best to save/restore. 

-- 9/22/2019 5:10

just need to jot down some thoughts about how i handle cutscenes and stuff...

i want to be able to fuck with cutscenes two ways: 
1. i'm playing the game, i can flip some bits through the editor or through the
   game itself, and then i can see if the cutscene triggers and if it does what
   i want it to do. "integration test".
2. i want to see if the cutscene just works mechanically. "unit test". 

right now the cutscene action loads up the cutscene test layer and triggers a
cutscene from that. that's definitely not what i want to do. first off, adding a
new layer was kind of a pain in the ass because it was easy to forget stuff
(update the console! do physics! update the camera!). second off, the -only-
thing that layer does is to run a cutscene. so it's just a kind of bullshit
piece of code. 

i could probably just smush that into the editor? 

also, side note, the battle layer is pretty whatever, so don't worry about
that. 

another thing with cutscenes, and i don't know if i am making shit too
complicated here, but doesn't there need to be a set state for a cutscene to
work? as in, should a cutscene only trigger if some certain flags are properly
set? i don't think so...this game is supposed to be linear. so if that is the
case, then i can just trigger a cutscene from literally anywhere and it will
work. 
** automation
I think that the automation/CLI should be written in C++, so I don't have to
write a parser for TDS in Python. 

Things I want it to do:
- Make new actions. This one is less than ideal because there's C++ code
  involved, so I'll have to recompile the game. If I had hotloading, though...
- Make new entities, and write their definitions out to a file.
  - Do this from templates. For example:
	- Prop template.

new entity wizard:
select a file where it's gonna be put. 
enter a name for it
select components
load up those components from template files (?)

uhh so i probably want to add this to the tds state tree. actually, i don't
think i do. what i want to do is build a table, then write it out to a file,
then script that file -- i mean, i already have the table, so it would be smart
to insert that table into the script tree. 

customize the components
** fuck
all of the actions turn into components ("SCRIPTS")

all the current components are default components that are a part of the engine
binary. 

expose API to user code by shipping with a header. it's all free functions. 

base component and entity classes have
#+BEGIN_SRC cpp
virtual void update(float dt);
#+END_SRC

something like
#+BEGIN_SRC cpp
#define REGISTER_COMPONENT(type) blah()
REGISTER_COMPONENT(Graphic);
#+END_SRC

everything still basically uses tdscript to serialize and deserialize. templates
are defined in tdscript. so is saved data. the main difference is that you ALSO
implement update(). 

components get owning entity
** The Big List
- Finish the story
  - Flesh out all of the characters
  - Write sidequests
  - Fine-tune pacing
- Balance the in-game
  - What creatures are in the game?
  - What moves are in the game?
  - What items are in the game?
  - What abilities are in the game?
  - How and at what rate do creatures become more powerful?
  - When do you have access to certain creatures?
- Balance the out of game
  - What does the metagame look like?
  - What macro strategies are available? 
- Design dungeons
  - Puzzles
  - Difficulty
- Art
  - Characters
	- Sprites
	- Heads
  - Battle Stuff
	- Creatures
	- Attacks
	- Items
  - Flashes
	- Pastoral Society
	- Smoldering Ruins
	- Mountain Pass
	- Frightened Deer
  - Levels
	- Boon's House
	- The City
	  - Boon's Neighborhood
	  - The Poor Area
	  - Ike's Hardware
	  - The Basement
	  - The Bar
	  - Announcement Podium
	  - The Restaurant
	- The Forest
	  - Camp
	  - Cream Palace
	- The Desert
	  - Barr's Outpost
	  - Landscape
	- Theseus' Lair
  - Dungeons
	- The Warehouse
	- The Slave Factory
	- The Police Station
	- The Capturehouse
	- The Forest (Boon)
	- The Forest (Sewell + Evans)
	- The Tunnel
	- The Mirage + The House
	- The Encampment
	- The Shed
- Music
* bugs
* polish
* features
next episode:
@spader 3/1/2020: movement component

@spader 3/1/2020: add time parameter to animation frames
@spader 3/1/2020: if/how scenes are going to be in the game. or how you'll
simulate the features a scene gives you.
@spader 3/1/2020: port tile selector
@spader 3/1/2020: components you will probably need for level 1...collision,
interaction, task, tile, dialogue, state
@spader 3/1/2020: autogenerate tile classes, probably with like a lua for loop?
tdengine.tile?
Scenes = {}
* closed
@spader 3/1/2020: Get the rendering system right. Ideally, there's a clever way
for every entity with a GC to register itself with the rendering engine. You
could probably do that in the GC constructor -- just call into some API that you
expose in C++.

@spader 3/1/2020: Inputs are kind of fucked right now. What's a good way to
handle chords of all kinds (shift included)? How do the game layers and scripts
read from the input buffer? n.b. this isn't quite done because I haven't
/implemented/ when masks are applied, but all the logic is pretty much there

@spader 3/1/2020: could prob autogenerate imgui stuff for entities
for member in entity:
  if type(member) == function then pass end
  if type(member) == number or string then display it
  if type(member) == table recurse

@spader 3/1/2020: moved engines/managers to jblow style functions
@spader 3/1/2020: fixed how inputs are masked to different layers, added inputs
to exported API
@spader 3/1/2020: found some GLFW key binding definitions
@spader 3/1/2020: wrote some basic camera code
@spader 3/1/2020: fixed the imgui binding generator 
@spader 3/1/2020: figured out how to wrap some of the stuff that doesn't cover.
@spader 3/1/2020: started porting the editor over to lua
@spader 3/1/2020: wrote a basic entity viewer 

@spader 3/1/2020: entity:print_once()
@spader 3/1/2020: tdengine.get_entity(name)
@spader 3/1/2020: finish off bitmask logic for inputs
@spader 3/1/2020: shift map

@spader 11/6/2019: Put some more thought into the API, and the separation of the
engine from the game. Do I want to make the engine as a DLL? Is that going to
supremely fuck all of my precious debuggability? As an alternative, I could
leave the game and the engine as one binary, but separate the code out such that
it would be really easy to snip them apart when the time comes. Binaries and
consumption aside, the real reason I want to do this is to get a better handle
on the responsibilities of each part. What is the core engine actually doing,
and what parts of the code truly belong to my game? Still in the back of my mind
have the idea of someone else using this engine. Wouldn't it be cool if this
engine was a super lightweight one that you modified by (gasp) actually touching
the source code? Actions and components are packaged up with it, but you can
easily mod it to allow user ones, too. 
* thoughts
@spader 3/2/2020: I want to avoid writing a lot of wrappers. Ideally, adding a
binding to the engine is one or two files. Most of the bindings into the engine
are going to be pretty thin wrappers. The layers look like this: 

Lowest level: ENGINE. 
Inside here, you have all the subsystems that actually do the work. The
rendering engine, the physics system, etc. 

Next level: API. 
Thin wrappers which are directly bound to Lua. The purpose of these
is to keep my Lua API nice and stable, and let me do whatever tricky things I
want with function signatures. Varargs, template stuff, whatever. Just register
a wrapper to Lua. 

Next level: SUGAR.
Thin wrappers in Lua. The purpose of these are purely sugar. For example, the
C++ API will take in integer IDs for entities, but I want to pass in the Lua
table because that looks natural. Write a wrapper that takes the Lua table and
forwards the ID to C++. 

Last level(?): COMPONENTS.
Components shouldn't be wrappers around the API per se -- they should put some
useful functionality on top of it. In other words, they talk to other components
and then decide what API functions to call. 

That doesn't seem too arduous. 
* gameplay
** types
The types are, flavor wise, supposed to represent the reflections of different
pure forms onto the physical realms. All things exist purely through dogma. The
precise qualities that make anything itself come from this. When they're
filtered down to the physical plane, some of these characteristics get lost. 

Battles involve creatures that are powerful manifestations of these traits. They
are also filtered when they enter our world, but their concentration is much
higher and they are therefore a more distilled representation of them. Because
they are so distilled, they can tap into other aspects of that trait that
regular things could not -- namely, pulling that essential force for battle. 

** [LG] logic
The intelligence of man. 

This type is good at indirect attacking. The first thing that means is that its
attack-oriented creatures are good at special attacking. No grapplers here. The
second thing is that its creatures get good support moves. 
- Stat boosting moves
- Substitute
- Baton Pass
- Trick Room
- Roar

Their typing defensively is a pretty clean 50. Their typing offensively is
probably closer to a 60, preferring to use power over type coverage to get the
job done
** [DS] dark spirit 
The evil nature of man. Corruption, greed, sloth, sadism, power, intimidation.

This type has a lot of offensive support moves and a lot of mix ups. Solid
STAB moves with fair coverage, but mostly based around the idea that you can
morph them into a lot of things. This would be a good place to have a utility
creature that can sweep or take on a number of specialized defensive roles. 

Inspirations:
Taunt Wisp Mew
BW Gliscor
BW Sableye
ADV Gengar
DPP UU Crobat
DPP UU Froslass

- Taunt
- Will-o-Wisp
- Explosion
- Destiny Bond
- Knock Off
- Pain Split
- Trick
- Drag Down (Ability): On turns where this creature uses a support move before
  an opponent can attack, creature takes half damage. 
- Spite (Ability): Any creatures active at the end of the turn lose 1/16th of
  their health, including this one. 
** [LS] light spirit
The good nature of man. Soft kindness, mothering, empathy, joy.

This type is where your pink blobs live. It has a lot of defensive support
moves. They don't carry momentum well in and of themselves, because they lack
the tools to directly pressure the opponent. Instead, they try to slow the game
down and remove key threats from the game. 

Defensive Dragonite

- Wish
- 50% recovery
- Seismic Toss
- Aromatherapy
- Encore
- Screens
- Calm Mind
- Good coverage but poor offensive stats
- Natural Cure
- Regenerator
- STABs that have useful secondary effects (e.g. Scald)
- Resilience (Ability): All passive damage done to this creature is halved. 
- Gift of Health (Move): Instantly heal 1/4 of any teammate's health
- In Tune (Ability): When this creature heals, it receives 1/10 more health than
  normal. 
** [RS] red spirit 
The passionate nature of man. 
** [EA] earth
The essence of physical material. (might make this a 'materia' type, give
different flavors like air and water)

This type is all about the physical attacks. Low special stats, both offensively
and defensive. Flavor-wise, focuses on moves that manipulate the non-living
material of the Earth. Earth will be a really good typing defensively and
offensively. Offensively, the problem will be that they don't get good coverage
moves -- maybe something like Rock Slide + Earthquake in ADV, but even that
might be a little too good. One or two key weaknesses that you can exploit (one
physical, one special?).

Inspirations:
BW Landorus-T
BW Excadrill
ADV Flygon

- Earthquake
- Swords Dance
- Lead Smoke (Move): The next creature to enter the field will lose 1/8 of its
  health
- Rock Slide
** [MC] machinery
You ain't machine and you ain't land. Machines are more organized than the chaos
of material, yet their organization holds a cold acid edge that is not truly
alive. Creatures of machine are extreme. They do few things, but they do them
well. Their stat spreads are heavily skewed to one of the few things that they
do, and so are their movepools. Their defensive typing is poor, but their
offensive typing is very good. They are bound by almost all things -- water,
material, human nature and ingenuity -- but at the same time they bind these
things as well. 

Visually, they'll all look like machines, but mechanically they'll focus on one
or two aspects of the game and be really good at that and pretty bad at
everything else. It will be hard to make these usable.

Inspirations
DPP Azelf
ADV Magneton
BW Bronzong
DPP Lucario
BW Gothitelle
ADV Forretress
BW Sableye

One that focuses on entry hazards
One that fucks up a fairly common defensive type
Glass cannon sweepers 
Suicide leads (hazards/screens/boom)

** [FR] fire
** [WA] water
necrotic? 
the mountains
god 
psychedelics
philosophy
science
art
fire
cells
ice
electricity
time
void -- things that completely lack type 
psychosis
animals
sages
** [FA] fauna
The spirit of the animal. Brutish, petty, yet surprisingly clever at
times. These are things that can hit you pretty good. Usually not a ton of
tricks up their sleeve -- they might have mixups, but it'll be clearer what
their options are from the things around them (e.g. pretty easy to spot a mix
lax). 

Inspirations:
ADV Tyranitar
ADV Metagross
ADV Snorlax
ADV Heracross
DPP Gyarados


** [FL] flora
The spirit of floral nature.

Inspirations:
Ferrothorn
Celesteela
Tornadus-Therian

This type is all about momentum (think about the beautiful flowing momentum with
which plants live). Floral types get lots of annoying support moves and
abilities
- Leech Seed
- Protect
- Toxic
- Stun Spore
- Toxic Spikes
- Spikes
- Iron Barbs (physical / special)
- Sap (Ability): Transfer 6% health from opponent to user at the end of each
  turn.
- Return to Nature (Ability): Every turn, regardless of whether this creature is
  active, it gains 1% of its health back
- Knock Off
- 50% Recovery

Their operating principle is to, at worst, make a trade. Every time a Floral is
on the field, SOMETHING should be happening to your advantage (even if the turn
itself is a net negative). 

** [DG] dogmatic
The pure essence of dogma. 

This type is the most well rounded type in the game. It provides a few well
rounded STAB moves, but more importantly offers key resistances and few
weaknesses which makes it highly sought after defensively. Dogmatic creatures
generally rely on their potent movepools to output lots of damage, and they use
their good typing to be excellent checks to other offensive threats. 

Inspirations:
BW Latios
BW Hydreigon 
BW Garchomp
ADV MixMence (closer to this in terms of power)
DPP Tyranitar

- Fire Blast
- Draco Meteor
- Brick Break
- A few weak but really useful coverage moves for mix-ups
- 100/90/90 defenses

** type chart
|    | LG | DS | LS | RS | EA | MC | FR | WA | FL | DG |
| LG |  0 |    |    |    |    |    |    |    |    |    |
| DS |    |  0 |    |    |    |    |    |    |    |    |
| LS |    |    |  0 |    |    |    |    |    |    |    |
| RS |    |    |    |  0 |    |    |    |    |    |    |
| EA |    |    |    |    |  0 |    |    |    |    |    |
| MC |    |    |    |    |    |  0 |    |    |    |    |
| FR |    |    |    |    |    |    |  0 |    |    |    |
| WA |    |    |    |    |    |    |    |  0 |    |    |
| FL |    |    |    |    |    |    |    |    |  0 |    |
| DG |    |    |    |    |    |    |    |    |    |  0 |

** moves
- Screens
- Wisp
- Toxic
- Thunder Wave
- Sleep Powder
- Refresh / Heal Bell
- Substitute
- 50% recovery
- Rest
- Haze
- Protect
- Perish Song
- Taunt
- Destiny Bond
- Focus Punch
- Baton Pass
- Doom Desire
- Encore
- Explosion
- Fake Out
- Hidden Power
- Magic Coat
- Memento
- Healing Wish
- Trick
- Pain Split
- Skill Swap
- Super Fang
- Thief
- Giga Drain
- Sedate (Light Spirit): User cannot use any attacking moves for two
  turns. Always goes last. 
